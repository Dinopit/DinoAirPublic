/**
 * Database Setup Script for DinoAir Supabase Integration
 * Creates required tables for chat sessions, messages, and metrics
 */

const { supabaseAdmin } = require('../lib/supabase');

/**
 * SQL statements to create the required tables
 */
const createTablesSQL = {
  // DinoAI Main Memory Database Table (created first, no dependencies)
  DinoAI: `
    CREATE TABLE IF NOT EXISTS public."DinoAI" (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      CONSTRAINT "DinoAI_pkey" PRIMARY KEY (id)
    ) TABLESPACE pg_default;
  `,

  // Chat Sessions Table (created first, no dependencies)
  chat_sessions: `
    CREATE TABLE IF NOT EXISTS chat_sessions (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id TEXT NOT NULL,
      created_at TIMESTAMPTZ DEFAULT NOW(),
      updated_at TIMESTAMPTZ DEFAULT NOW(),
      metadata JSONB DEFAULT '{}'::jsonb,
      CONSTRAINT chat_sessions_user_id_check CHECK (char_length(user_id) > 0)
    );
  `,

  // Chat Messages Table (depends on chat_sessions)
  chat_messages: `
    CREATE TABLE IF NOT EXISTS chat_messages (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      session_id UUID NOT NULL,
      role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
      content TEXT NOT NULL,
      created_at TIMESTAMPTZ DEFAULT NOW(),
      metadata JSONB DEFAULT '{}'::jsonb,
      CONSTRAINT chat_messages_content_check CHECK (char_length(content) > 0)
    );
  `,

  // Chat Metrics Table (depends on chat_sessions)
  chat_metrics: `
    CREATE TABLE IF NOT EXISTS chat_metrics (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      session_id UUID NOT NULL,
      model TEXT NOT NULL,
      response_time_ms INTEGER NOT NULL CHECK (response_time_ms >= 0),
      token_count INTEGER NOT NULL CHECK (token_count >= 0),
      created_at TIMESTAMPTZ DEFAULT NOW(),
      metadata JSONB DEFAULT '{}'::jsonb,
      CONSTRAINT chat_metrics_model_check CHECK (char_length(model) > 0)
    );
  `,

  // Artifacts Table (independent table for artifact storage)
  artifacts: `
    CREATE TABLE IF NOT EXISTS artifacts (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      name TEXT NOT NULL,
      type TEXT NOT NULL,
      content TEXT NOT NULL,
      size INTEGER NOT NULL CHECK (size >= 0),
      user_id TEXT,
      version INTEGER NOT NULL DEFAULT 1 CHECK (version > 0),
      parent_id UUID,
      tags TEXT[] DEFAULT '{}',
      metadata JSONB DEFAULT '{}'::jsonb,
      created_at TIMESTAMPTZ DEFAULT NOW(),
      updated_at TIMESTAMPTZ DEFAULT NOW(),
      CONSTRAINT artifacts_name_check CHECK (char_length(name) > 0),
      CONSTRAINT artifacts_type_check CHECK (char_length(type) > 0),
      CONSTRAINT artifacts_content_check CHECK (char_length(content) > 0)
    );
  `,

  // User Sessions Table (for database-backed session storage)
  user_sessions: `
    CREATE TABLE IF NOT EXISTS user_sessions (
      id TEXT PRIMARY KEY,
      user_id TEXT NOT NULL,
      data JSONB DEFAULT '{}'::jsonb,
      expires_at TIMESTAMPTZ NOT NULL,
      created_at TIMESTAMPTZ DEFAULT NOW(),
      updated_at TIMESTAMPTZ DEFAULT NOW(),
      CONSTRAINT user_sessions_user_id_check CHECK (char_length(user_id) > 0),
      CONSTRAINT user_sessions_id_check CHECK (char_length(id) > 0)
    );
  `,

  // JWT Refresh Tokens Table (for token management)
  refresh_tokens: `
    CREATE TABLE IF NOT EXISTS refresh_tokens (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id TEXT NOT NULL,
      token_hash TEXT NOT NULL UNIQUE,
      expires_at TIMESTAMPTZ NOT NULL,
      created_at TIMESTAMPTZ DEFAULT NOW(),
      revoked_at TIMESTAMPTZ,
      device_info JSONB DEFAULT '{}'::jsonb,
      CONSTRAINT refresh_tokens_user_id_check CHECK (char_length(user_id) > 0),
      CONSTRAINT refresh_tokens_token_hash_check CHECK (char_length(token_hash) > 0)
    );
  `
};

/**
 * SQL statements to create indexes (after tables are created)
 */
const createIndexesSQL = {
  DinoAI: `
    CREATE INDEX IF NOT EXISTS "idx_DinoAI_created_at" ON public."DinoAI"(created_at);
    CREATE INDEX IF NOT EXISTS "idx_DinoAI_id" ON public."DinoAI"(id);
  `,
  chat_sessions: `
    CREATE INDEX IF NOT EXISTS idx_chat_sessions_user_id ON chat_sessions(user_id);
    CREATE INDEX IF NOT EXISTS idx_chat_sessions_created_at ON chat_sessions(created_at);
    CREATE INDEX IF NOT EXISTS idx_chat_sessions_updated_at ON chat_sessions(updated_at);
  `,
  chat_messages: `
    CREATE INDEX IF NOT EXISTS idx_chat_messages_session_id ON chat_messages(session_id);
    CREATE INDEX IF NOT EXISTS idx_chat_messages_created_at ON chat_messages(created_at);
    CREATE INDEX IF NOT EXISTS idx_chat_messages_role ON chat_messages(role);
  `,
  chat_metrics: `
    CREATE INDEX IF NOT EXISTS idx_chat_metrics_session_id ON chat_metrics(session_id);
    CREATE INDEX IF NOT EXISTS idx_chat_metrics_created_at ON chat_metrics(created_at);
    CREATE INDEX IF NOT EXISTS idx_chat_metrics_model ON chat_metrics(model);
  `,
  artifacts: `
    CREATE INDEX IF NOT EXISTS idx_artifacts_user_id ON artifacts(user_id);
    CREATE INDEX IF NOT EXISTS idx_artifacts_created_at ON artifacts(created_at);
    CREATE INDEX IF NOT EXISTS idx_artifacts_updated_at ON artifacts(updated_at);
    CREATE INDEX IF NOT EXISTS idx_artifacts_type ON artifacts(type);
    CREATE INDEX IF NOT EXISTS idx_artifacts_name ON artifacts(name);
    CREATE INDEX IF NOT EXISTS idx_artifacts_parent_id ON artifacts(parent_id);
    CREATE INDEX IF NOT EXISTS idx_artifacts_version ON artifacts(version);
    CREATE INDEX IF NOT EXISTS idx_artifacts_tags ON artifacts USING GIN(tags);
    CREATE INDEX IF NOT EXISTS idx_artifacts_metadata ON artifacts USING GIN(metadata);
  `,
  user_sessions: `
    CREATE INDEX IF NOT EXISTS idx_user_sessions_user_id ON user_sessions(user_id);
    CREATE INDEX IF NOT EXISTS idx_user_sessions_expires_at ON user_sessions(expires_at);
    CREATE INDEX IF NOT EXISTS idx_user_sessions_created_at ON user_sessions(created_at);
    CREATE INDEX IF NOT EXISTS idx_user_sessions_updated_at ON user_sessions(updated_at);
  `,
  refresh_tokens: `
    CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON refresh_tokens(user_id);
    CREATE INDEX IF NOT EXISTS idx_refresh_tokens_token_hash ON refresh_tokens(token_hash);
    CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires_at ON refresh_tokens(expires_at);
    CREATE INDEX IF NOT EXISTS idx_refresh_tokens_created_at ON refresh_tokens(created_at);
    CREATE INDEX IF NOT EXISTS idx_refresh_tokens_revoked_at ON refresh_tokens(revoked_at);
  `
};

/**
 * SQL statements to create foreign key constraints (after all tables exist)
 */
const createConstraintsSQL = {
  chat_messages: `
    ALTER TABLE chat_messages 
    ADD CONSTRAINT IF NOT EXISTS fk_chat_messages_session_id 
    FOREIGN KEY (session_id) REFERENCES chat_sessions(id) ON DELETE CASCADE;
  `,
  chat_metrics: `
    ALTER TABLE chat_metrics 
    ADD CONSTRAINT IF NOT EXISTS fk_chat_metrics_session_id 
    FOREIGN KEY (session_id) REFERENCES chat_sessions(id) ON DELETE CASCADE;
  `,
  artifacts: `
    ALTER TABLE artifacts 
    ADD CONSTRAINT IF NOT EXISTS fk_artifacts_parent_id 
    FOREIGN KEY (parent_id) REFERENCES artifacts(id) ON DELETE SET NULL;
  `
};

/**
 * Row Level Security (RLS) policies
 */
const createRLSPolicies = {
  DinoAI: `
    -- Enable RLS
    ALTER TABLE public."DinoAI" ENABLE ROW LEVEL SECURITY;
    
    -- Policy: Allow all authenticated users to read from DinoAI
    CREATE POLICY IF NOT EXISTS "Allow authenticated read access" ON public."DinoAI"
      FOR SELECT USING (auth.role() = 'authenticated' OR auth.role() = 'anon');
    
    -- Policy: Allow all authenticated users to insert into DinoAI
    CREATE POLICY IF NOT EXISTS "Allow authenticated insert access" ON public."DinoAI"
      FOR INSERT WITH CHECK (auth.role() = 'authenticated' OR auth.role() = 'anon');
    
    -- Policy: Service role can access all DinoAI records
    CREATE POLICY IF NOT EXISTS "Service role can access all DinoAI" ON public."DinoAI"
      FOR ALL USING (auth.role() = 'service_role');
  `,

  chat_sessions: `
    -- Enable RLS
    ALTER TABLE chat_sessions ENABLE ROW LEVEL SECURITY;
    
    -- Policy: Users can only access their own sessions
    CREATE POLICY IF NOT EXISTS "Users can access own sessions" ON chat_sessions
      FOR ALL USING (auth.uid()::text = user_id);
    
    -- Policy: Service role can access all sessions
    CREATE POLICY IF NOT EXISTS "Service role can access all sessions" ON chat_sessions
      FOR ALL USING (auth.role() = 'service_role');
  `,

  chat_messages: `
    -- Enable RLS
    ALTER TABLE chat_messages ENABLE ROW LEVEL SECURITY;
    
    -- Policy: Users can access messages from their own sessions
    CREATE POLICY IF NOT EXISTS "Users can access own session messages" ON chat_messages
      FOR ALL USING (
        EXISTS (
          SELECT 1 FROM chat_sessions 
          WHERE chat_sessions.id = chat_messages.session_id 
          AND chat_sessions.user_id = auth.uid()::text
        )
      );
    
    -- Policy: Service role can access all messages
    CREATE POLICY IF NOT EXISTS "Service role can access all messages" ON chat_messages
      FOR ALL USING (auth.role() = 'service_role');
  `,

  chat_metrics: `
    -- Enable RLS
    ALTER TABLE chat_metrics ENABLE ROW LEVEL SECURITY;
    
    -- Policy: Users can access metrics from their own sessions
    CREATE POLICY IF NOT EXISTS "Users can access own session metrics" ON chat_metrics
      FOR ALL USING (
        EXISTS (
          SELECT 1 FROM chat_sessions 
          WHERE chat_sessions.id = chat_metrics.session_id 
          AND chat_sessions.user_id = auth.uid()::text
        )
      );
    
    -- Policy: Service role can access all metrics
    CREATE POLICY IF NOT EXISTS "Service role can access all metrics" ON chat_metrics
      FOR ALL USING (auth.role() = 'service_role');
  `,

  artifacts: `
    -- Enable RLS
    ALTER TABLE artifacts ENABLE ROW LEVEL SECURITY;
    
    -- Policy: Users can access their own artifacts
    CREATE POLICY IF NOT EXISTS "Users can access own artifacts" ON artifacts
      FOR ALL USING (
        user_id IS NULL OR user_id = auth.uid()::text
      );
    
    -- Policy: Anonymous users can access public artifacts (where user_id is NULL)
    CREATE POLICY IF NOT EXISTS "Anonymous can access public artifacts" ON artifacts
      FOR SELECT USING (user_id IS NULL);
    
    -- Policy: Authenticated users can create artifacts
    CREATE POLICY IF NOT EXISTS "Authenticated users can create artifacts" ON artifacts
      FOR INSERT WITH CHECK (
        auth.role() = 'authenticated' AND 
        (user_id IS NULL OR user_id = auth.uid()::text)
      );
    
    -- Policy: Service role can access all artifacts
    CREATE POLICY IF NOT EXISTS "Service role can access all artifacts" ON artifacts
      FOR ALL USING (auth.role() = 'service_role');
  `,

  user_sessions: `
    -- Enable RLS
    ALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;
    
    -- Policy: Users can access their own sessions
    CREATE POLICY IF NOT EXISTS "Users can access own sessions" ON user_sessions
      FOR ALL USING (user_id = auth.uid()::text);
    
    -- Policy: Service role can access all sessions
    CREATE POLICY IF NOT EXISTS "Service role can access all sessions" ON user_sessions
      FOR ALL USING (auth.role() = 'service_role');
  `,

  refresh_tokens: `
    -- Enable RLS
    ALTER TABLE refresh_tokens ENABLE ROW LEVEL SECURITY;
    
    -- Policy: Users can access their own refresh tokens
    CREATE POLICY IF NOT EXISTS "Users can access own refresh tokens" ON refresh_tokens
      FOR ALL USING (user_id = auth.uid()::text);
    
    -- Policy: Service role can access all refresh tokens
    CREATE POLICY IF NOT EXISTS "Service role can access all refresh tokens" ON refresh_tokens
      FOR ALL USING (auth.role() = 'service_role');
  `
};

/**
 * Execute SQL statement using Supabase admin client
 * @param {string} sql - SQL statement to execute
 * @param {string} description - Description of the operation
 */
async function executeSQLStatement(sql, description) {
  try {
    console.log(`Executing: ${description}...`);
    
    const { data, error } = await supabaseAdmin.rpc('exec_sql', {
      sql_query: sql
    });

    if (error) {
      // If the RPC function doesn't exist, try direct SQL execution
      if (error.code === '42883') {
        console.log('RPC function not available, trying alternative method...');
        
        // For table creation, we can use the REST API with raw SQL
        const response = await fetch(`${process.env.SUPABASE_URL}/rest/v1/rpc/exec_sql`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}`,
            'apikey': process.env.SUPABASE_SERVICE_ROLE_KEY
          },
          body: JSON.stringify({ sql_query: sql })
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${await response.text()}`);
        }

        console.log(`‚úÖ ${description} completed successfully`);
        return;
      }
      
      throw error;
    }

    console.log(`‚úÖ ${description} completed successfully`);
  } catch (error) {
    console.error(`‚ùå Failed to execute ${description}:`, error.message);
    throw error;
  }
}

/**
 * Create database tables
 */
async function createTables() {
  console.log('\nüîß Creating database tables...\n');

  try {
    // Step 1: Create tables in order (DinoAI first, then sessions, then dependent tables)
    await executeSQLStatement(createTablesSQL.DinoAI, 'Create DinoAI main memory table');
    await executeSQLStatement(createTablesSQL.chat_sessions, 'Create chat_sessions table');
    await executeSQLStatement(createTablesSQL.chat_messages, 'Create chat_messages table');
    await executeSQLStatement(createTablesSQL.chat_metrics, 'Create chat_metrics table');
    await executeSQLStatement(createTablesSQL.artifacts, 'Create artifacts table');
    await executeSQLStatement(createTablesSQL.user_sessions, 'Create user_sessions table');
    await executeSQLStatement(createTablesSQL.refresh_tokens, 'Create refresh_tokens table');

    // Step 2: Create indexes for better performance
    console.log('\nüîß Creating indexes...\n');
    await executeSQLStatement(createIndexesSQL.DinoAI, 'Create indexes for DinoAI');
    await executeSQLStatement(createIndexesSQL.chat_sessions, 'Create indexes for chat_sessions');
    await executeSQLStatement(createIndexesSQL.chat_messages, 'Create indexes for chat_messages');
    await executeSQLStatement(createIndexesSQL.chat_metrics, 'Create indexes for chat_metrics');
    await executeSQLStatement(createIndexesSQL.artifacts, 'Create indexes for artifacts');
    await executeSQLStatement(createIndexesSQL.user_sessions, 'Create indexes for user_sessions');
    await executeSQLStatement(createIndexesSQL.refresh_tokens, 'Create indexes for refresh_tokens');

    // Step 3: Add foreign key constraints
    console.log('\nüîß Adding foreign key constraints...\n');
    await executeSQLStatement(createConstraintsSQL.chat_messages, 'Add foreign key constraint for chat_messages');
    await executeSQLStatement(createConstraintsSQL.chat_metrics, 'Add foreign key constraint for chat_metrics');
    await executeSQLStatement(createConstraintsSQL.artifacts, 'Add foreign key constraint for artifacts');

    console.log('\n‚úÖ All tables, indexes, and constraints created successfully!');
  } catch (error) {
    console.error('\n‚ùå Failed to create tables:', error.message);
    throw error;
  }
}

/**
 * Set up Row Level Security policies
 */
async function setupRLS() {
  console.log('\nüîí Setting up Row Level Security policies...\n');

  try {
    await executeSQLStatement(createRLSPolicies.DinoAI, 'Setup RLS for DinoAI');
    await executeSQLStatement(createRLSPolicies.chat_sessions, 'Setup RLS for chat_sessions');
    await executeSQLStatement(createRLSPolicies.chat_messages, 'Setup RLS for chat_messages');
    await executeSQLStatement(createRLSPolicies.chat_metrics, 'Setup RLS for chat_metrics');
    await executeSQLStatement(createRLSPolicies.artifacts, 'Setup RLS for artifacts');
    await executeSQLStatement(createRLSPolicies.user_sessions, 'Setup RLS for user_sessions');
    await executeSQLStatement(createRLSPolicies.refresh_tokens, 'Setup RLS for refresh_tokens');

    console.log('\n‚úÖ Row Level Security policies configured successfully!');
  } catch (error) {
    console.error('\n‚ùå Failed to setup RLS policies:', error.message);
    console.log('Note: RLS policies may need to be configured manually in the Supabase dashboard.');
  }
}

/**
 * Verify table creation
 */
async function verifyTables() {
  console.log('\nüîç Verifying table creation...\n');

  const tables = ['DinoAI', 'chat_sessions', 'chat_messages', 'chat_metrics', 'artifacts', 'user_sessions', 'refresh_tokens'];
  
  for (const table of tables) {
    try {
      const { data, error } = await supabaseAdmin
        .from(table)
        .select('*')
        .limit(1);

      if (error && error.code !== 'PGRST116') {
        throw error;
      }

      console.log(`‚úÖ Table '${table}' is accessible`);
    } catch (error) {
      console.error(`‚ùå Table '${table}' verification failed:`, error.message);
      throw error;
    }
  }

  console.log('\n‚úÖ All tables verified successfully!');
}

/**
 * Main setup function
 */
async function setupDatabase() {
  console.log('üöÄ DinoAir Database Setup Starting...\n');
  console.log('This script will create the required tables for chat functionality.\n');

  try {
    // Test connection first
    console.log('üîó Testing Supabase connection...');
    const { data, error } = await supabaseAdmin.from('information_schema.tables').select('table_name').limit(1);
    
    if (error) {
      throw new Error(`Connection failed: ${error.message}`);
    }
    
    console.log('‚úÖ Supabase connection successful!\n');

    // Create tables
    await createTables();

    // Setup RLS (optional, may fail if permissions are insufficient)
    try {
      await setupRLS();
    } catch (error) {
      console.log('\n‚ö†Ô∏è  RLS setup skipped - may need manual configuration in Supabase dashboard');
    }

    // Verify tables
    await verifyTables();

    console.log('\nüéâ Database setup completed successfully!');
    console.log('\nYou can now use the DinoAir chat application with Supabase integration.');
    
  } catch (error) {
    console.error('\nüí• Database setup failed:', error.message);
    console.log('\nPlease check your Supabase configuration and try again.');
    console.log('You may need to create the tables manually in the Supabase SQL editor.');
    
    // Print the SQL statements for manual execution
    console.log('\nüìã SQL statements for manual execution:');
    console.log('\n-- Chat Sessions Table:');
    console.log(createTablesSQL.chat_sessions);
    console.log('\n-- Chat Messages Table:');
    console.log(createTablesSQL.chat_messages);
    console.log('\n-- Chat Metrics Table:');
    console.log(createTablesSQL.chat_metrics);
    
    process.exit(1);
  }
}

// Run the setup if this script is executed directly
if (require.main === module) {
  setupDatabase();
}

module.exports = {
  setupDatabase,
  createTables,
  setupRLS,
  verifyTables
};